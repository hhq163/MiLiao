// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Buddy.proto

#ifndef PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
#define PROTOBUF_IM_2eBuddy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace Buddy {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eBuddy_2eproto();
void protobuf_AssignDesc_IM_2eBuddy_2eproto();
void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

class IMRecentContactSessionReq;
class IMRecentContactSessionRsp;
class IMUserStatNotify;
class IMUsersInfoReq;
class IMUsersInfoRsp;
class IMRemoveSessionReq;
class IMRemoveSessionRsp;
class IMAllUserReq;
class IMAllUserRsp;
class IMUsersStatReq;
class IMUsersStatRsp;
class IMChangeAvatarReq;
class IMChangeAvatarRsp;
class IMPCLoginStatusNotify;
class IMRemoveSessionNotify;
class IMDepartmentReq;
class IMDepartmentRsp;
class IMAvatarChangedNotify;
class IMChangeSignInfoReq;
class IMChangeSignInfoRsp;
class IMSignInfoChangedNotify;
class IMUserSearchReq;
class IMUserSearchRsp;
class IMUserAddFriendReq;
class IMUserAddFriendRsp;
class IMUserRemFriendReq;
class IMUserRemFriendRsp;
class IMUserInfoChangeReq;
class IMUserInfoChangeRsp;
class IMUserAddFriendToUserRsp;
class IMUserAddFriendTargetReq;
class IMUserAddFriendTargetRsp;
class IMUserAddFriendToSelfRsp;
class IMSendDelMsgToTargetRsp;

// ===================================================================

class IMRecentContactSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionReq();
  virtual ~IMRecentContactSessionReq();

  IMRecentContactSessionReq(const IMRecentContactSessionReq& from);

  inline IMRecentContactSessionReq& operator=(const IMRecentContactSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecentContactSessionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecentContactSessionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecentContactSessionReq* other);

  // implements Message ----------------------------------------------

  IMRecentContactSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionReq& from);
  void MergeFrom(const IMRecentContactSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecentContactSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRecentContactSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionRsp();
  virtual ~IMRecentContactSessionRsp();

  IMRecentContactSessionRsp(const IMRecentContactSessionRsp& from);

  inline IMRecentContactSessionRsp& operator=(const IMRecentContactSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRecentContactSessionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRecentContactSessionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRecentContactSessionRsp* other);

  // implements Message ----------------------------------------------

  IMRecentContactSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionRsp& from);
  void MergeFrom(const IMRecentContactSessionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
  inline int contact_session_list_size() const;
  inline void clear_contact_session_list();
  static const int kContactSessionListFieldNumber = 2;
  inline const ::IM::BaseDefine::ContactSessionInfo& contact_session_list(int index) const;
  inline ::IM::BaseDefine::ContactSessionInfo* mutable_contact_session_list(int index);
  inline ::IM::BaseDefine::ContactSessionInfo* add_contact_session_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
      contact_session_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
      mutable_contact_session_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo > contact_session_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRecentContactSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserStatNotify : public ::google::protobuf::MessageLite {
 public:
  IMUserStatNotify();
  virtual ~IMUserStatNotify();

  IMUserStatNotify(const IMUserStatNotify& from);

  inline IMUserStatNotify& operator=(const IMUserStatNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserStatNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserStatNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserStatNotify* other);

  // implements Message ----------------------------------------------

  IMUserStatNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserStatNotify& from);
  void MergeFrom(const IMUserStatNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.UserStat user_stat = 1;
  inline bool has_user_stat() const;
  inline void clear_user_stat();
  static const int kUserStatFieldNumber = 1;
  inline const ::IM::BaseDefine::UserStat& user_stat() const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat();
  inline ::IM::BaseDefine::UserStat* release_user_stat();
  inline void set_allocated_user_stat(::IM::BaseDefine::UserStat* user_stat);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserStatNotify)
 private:
  inline void set_has_user_stat();
  inline void clear_has_user_stat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::BaseDefine::UserStat* user_stat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserStatNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoReq();
  virtual ~IMUsersInfoReq();

  IMUsersInfoReq(const IMUsersInfoReq& from);

  inline IMUsersInfoReq& operator=(const IMUsersInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersInfoReq* other);

  // implements Message ----------------------------------------------

  IMUsersInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoReq& from);
  void MergeFrom(const IMUsersInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoRsp();
  virtual ~IMUsersInfoRsp();

  IMUsersInfoRsp(const IMUsersInfoRsp& from);

  inline IMUsersInfoRsp& operator=(const IMUsersInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersInfoRsp* other);

  // implements Message ----------------------------------------------

  IMUsersInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoRsp& from);
  void MergeFrom(const IMUsersInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
  inline int user_info_list_size() const;
  inline void clear_user_info_list();
  static const int kUserInfoListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserInfo& user_info_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_info_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_info_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionReq();
  virtual ~IMRemoveSessionReq();

  IMRemoveSessionReq(const IMRemoveSessionReq& from);

  inline IMRemoveSessionReq& operator=(const IMRemoveSessionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionReq* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionReq& from);
  void MergeFrom(const IMRemoveSessionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionRsp();
  virtual ~IMRemoveSessionRsp();

  IMRemoveSessionRsp(const IMRemoveSessionRsp& from);

  inline IMRemoveSessionRsp& operator=(const IMRemoveSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionRsp* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionRsp& from);
  void MergeFrom(const IMRemoveSessionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 3;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 3;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserReq : public ::google::protobuf::MessageLite {
 public:
  IMAllUserReq();
  virtual ~IMAllUserReq();

  IMAllUserReq(const IMAllUserReq& from);

  inline IMAllUserReq& operator=(const IMAllUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAllUserReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAllUserReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAllUserReq* other);

  // implements Message ----------------------------------------------

  IMAllUserReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserReq& from);
  void MergeFrom(const IMAllUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAllUserReq* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserRsp : public ::google::protobuf::MessageLite {
 public:
  IMAllUserRsp();
  virtual ~IMAllUserRsp();

  IMAllUserRsp(const IMAllUserRsp& from);

  inline IMAllUserRsp& operator=(const IMAllUserRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAllUserRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAllUserRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAllUserRsp* other);

  // implements Message ----------------------------------------------

  IMAllUserRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserRsp& from);
  void MergeFrom(const IMAllUserRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo user_list = 3;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 3;
  inline const ::IM::BaseDefine::UserInfo& user_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAllUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatReq();
  virtual ~IMUsersStatReq();

  IMUsersStatReq(const IMUsersStatReq& from);

  inline IMUsersStatReq& operator=(const IMUsersStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersStatReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersStatReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersStatReq* other);

  // implements Message ----------------------------------------------

  IMUsersStatReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatReq& from);
  void MergeFrom(const IMUsersStatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersStatReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatRsp();
  virtual ~IMUsersStatRsp();

  IMUsersStatRsp(const IMUsersStatRsp& from);

  inline IMUsersStatRsp& operator=(const IMUsersStatRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUsersStatRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUsersStatRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUsersStatRsp* other);

  // implements Message ----------------------------------------------

  IMUsersStatRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatRsp& from);
  void MergeFrom(const IMUsersStatRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
  inline int user_stat_list_size() const;
  inline void clear_user_stat_list();
  static const int kUserStatListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserStat& user_stat_list(int index) const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat_list(int index);
  inline ::IM::BaseDefine::UserStat* add_user_stat_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
      user_stat_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
      mutable_user_stat_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat > user_stat_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUsersStatRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarReq : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarReq();
  virtual ~IMChangeAvatarReq();

  IMChangeAvatarReq(const IMChangeAvatarReq& from);

  inline IMChangeAvatarReq& operator=(const IMChangeAvatarReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeAvatarReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeAvatarReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeAvatarReq* other);

  // implements Message ----------------------------------------------

  IMChangeAvatarReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarReq& from);
  void MergeFrom(const IMChangeAvatarReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string avatar_url = 2;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatar_url_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeAvatarReq* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarRsp : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarRsp();
  virtual ~IMChangeAvatarRsp();

  IMChangeAvatarRsp(const IMChangeAvatarRsp& from);

  inline IMChangeAvatarRsp& operator=(const IMChangeAvatarRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeAvatarRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeAvatarRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeAvatarRsp* other);

  // implements Message ----------------------------------------------

  IMChangeAvatarRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarRsp& from);
  void MergeFrom(const IMChangeAvatarRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeAvatarRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMPCLoginStatusNotify : public ::google::protobuf::MessageLite {
 public:
  IMPCLoginStatusNotify();
  virtual ~IMPCLoginStatusNotify();

  IMPCLoginStatusNotify(const IMPCLoginStatusNotify& from);

  inline IMPCLoginStatusNotify& operator=(const IMPCLoginStatusNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMPCLoginStatusNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMPCLoginStatusNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMPCLoginStatusNotify* other);

  // implements Message ----------------------------------------------

  IMPCLoginStatusNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMPCLoginStatusNotify& from);
  void MergeFrom(const IMPCLoginStatusNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserStatType login_stat = 2;
  inline bool has_login_stat() const;
  inline void clear_login_stat();
  static const int kLoginStatFieldNumber = 2;
  inline ::IM::BaseDefine::UserStatType login_stat() const;
  inline void set_login_stat(::IM::BaseDefine::UserStatType value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMPCLoginStatusNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_login_stat();
  inline void clear_has_login_stat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int login_stat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMPCLoginStatusNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionNotify : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionNotify();
  virtual ~IMRemoveSessionNotify();

  IMRemoveSessionNotify(const IMRemoveSessionNotify& from);

  inline IMRemoveSessionNotify& operator=(const IMRemoveSessionNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMRemoveSessionNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMRemoveSessionNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMRemoveSessionNotify* other);

  // implements Message ----------------------------------------------

  IMRemoveSessionNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionNotify& from);
  void MergeFrom(const IMRemoveSessionNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMRemoveSessionNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentReq : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentReq();
  virtual ~IMDepartmentReq();

  IMDepartmentReq(const IMDepartmentReq& from);

  inline IMDepartmentReq& operator=(const IMDepartmentReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDepartmentReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDepartmentReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDepartmentReq* other);

  // implements Message ----------------------------------------------

  IMDepartmentReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentReq& from);
  void MergeFrom(const IMDepartmentReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDepartmentReq* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentRsp : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentRsp();
  virtual ~IMDepartmentRsp();

  IMDepartmentRsp(const IMDepartmentRsp& from);

  inline IMDepartmentRsp& operator=(const IMDepartmentRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMDepartmentRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMDepartmentRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMDepartmentRsp* other);

  // implements Message ----------------------------------------------

  IMDepartmentRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentRsp& from);
  void MergeFrom(const IMDepartmentRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
  inline int dept_list_size() const;
  inline void clear_dept_list();
  static const int kDeptListFieldNumber = 3;
  inline const ::IM::BaseDefine::DepartInfo& dept_list(int index) const;
  inline ::IM::BaseDefine::DepartInfo* mutable_dept_list(int index);
  inline ::IM::BaseDefine::DepartInfo* add_dept_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
      dept_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
      mutable_dept_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo > dept_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMDepartmentRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAvatarChangedNotify : public ::google::protobuf::MessageLite {
 public:
  IMAvatarChangedNotify();
  virtual ~IMAvatarChangedNotify();

  IMAvatarChangedNotify(const IMAvatarChangedNotify& from);

  inline IMAvatarChangedNotify& operator=(const IMAvatarChangedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMAvatarChangedNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMAvatarChangedNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMAvatarChangedNotify* other);

  // implements Message ----------------------------------------------

  IMAvatarChangedNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAvatarChangedNotify& from);
  void MergeFrom(const IMAvatarChangedNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 changed_user_id = 1;
  inline bool has_changed_user_id() const;
  inline void clear_changed_user_id();
  static const int kChangedUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 changed_user_id() const;
  inline void set_changed_user_id(::google::protobuf::uint32 value);

  // required string avatar_url = 2;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAvatarChangedNotify)
 private:
  inline void set_has_changed_user_id();
  inline void clear_has_changed_user_id();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatar_url_;
  ::google::protobuf::uint32 changed_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMAvatarChangedNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeSignInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMChangeSignInfoReq();
  virtual ~IMChangeSignInfoReq();

  IMChangeSignInfoReq(const IMChangeSignInfoReq& from);

  inline IMChangeSignInfoReq& operator=(const IMChangeSignInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeSignInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeSignInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeSignInfoReq* other);

  // implements Message ----------------------------------------------

  IMChangeSignInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeSignInfoReq& from);
  void MergeFrom(const IMChangeSignInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string sign_info = 2;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 2;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeSignInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sign_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeSignInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeSignInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMChangeSignInfoRsp();
  virtual ~IMChangeSignInfoRsp();

  IMChangeSignInfoRsp(const IMChangeSignInfoRsp& from);

  inline IMChangeSignInfoRsp& operator=(const IMChangeSignInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMChangeSignInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMChangeSignInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMChangeSignInfoRsp* other);

  // implements Message ----------------------------------------------

  IMChangeSignInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeSignInfoRsp& from);
  void MergeFrom(const IMChangeSignInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional string sign_info = 3;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 3;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeSignInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* sign_info_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMChangeSignInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMSignInfoChangedNotify : public ::google::protobuf::MessageLite {
 public:
  IMSignInfoChangedNotify();
  virtual ~IMSignInfoChangedNotify();

  IMSignInfoChangedNotify(const IMSignInfoChangedNotify& from);

  inline IMSignInfoChangedNotify& operator=(const IMSignInfoChangedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSignInfoChangedNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSignInfoChangedNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSignInfoChangedNotify* other);

  // implements Message ----------------------------------------------

  IMSignInfoChangedNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSignInfoChangedNotify& from);
  void MergeFrom(const IMSignInfoChangedNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 changed_user_id = 1;
  inline bool has_changed_user_id() const;
  inline void clear_changed_user_id();
  static const int kChangedUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 changed_user_id() const;
  inline void set_changed_user_id(::google::protobuf::uint32 value);

  // required string sign_info = 2;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 2;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMSignInfoChangedNotify)
 private:
  inline void set_has_changed_user_id();
  inline void clear_has_changed_user_id();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sign_info_;
  ::google::protobuf::uint32 changed_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMSignInfoChangedNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMUserSearchReq : public ::google::protobuf::MessageLite {
 public:
  IMUserSearchReq();
  virtual ~IMUserSearchReq();

  IMUserSearchReq(const IMUserSearchReq& from);

  inline IMUserSearchReq& operator=(const IMUserSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserSearchReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserSearchReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserSearchReq* other);

  // implements Message ----------------------------------------------

  IMUserSearchReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserSearchReq& from);
  void MergeFrom(const IMUserSearchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required uint32 search_type = 3;
  inline bool has_search_type() const;
  inline void clear_search_type();
  static const int kSearchTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 search_type() const;
  inline void set_search_type(::google::protobuf::uint32 value);

  // required uint32 search_seq = 4;
  inline bool has_search_seq() const;
  inline void clear_search_seq();
  static const int kSearchSeqFieldNumber = 4;
  inline ::google::protobuf::uint32 search_seq() const;
  inline void set_search_seq(::google::protobuf::uint32 value);

  // required uint32 page_size = 5;
  inline bool has_page_size() const;
  inline void clear_page_size();
  static const int kPageSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 page_size() const;
  inline void set_page_size(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserSearchReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_search_type();
  inline void clear_has_search_type();
  inline void set_has_search_seq();
  inline void clear_has_search_seq();
  inline void set_has_page_size();
  inline void clear_has_page_size();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 search_type_;
  ::google::protobuf::uint32 search_seq_;
  ::google::protobuf::uint32 page_size_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUserSearchRsp : public ::google::protobuf::MessageLite {
 public:
  IMUserSearchRsp();
  virtual ~IMUserSearchRsp();

  IMUserSearchRsp(const IMUserSearchRsp& from);

  inline IMUserSearchRsp& operator=(const IMUserSearchRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserSearchRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserSearchRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserSearchRsp* other);

  // implements Message ----------------------------------------------

  IMUserSearchRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserSearchRsp& from);
  void MergeFrom(const IMUserSearchRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 search_type = 2;
  inline bool has_search_type() const;
  inline void clear_search_type();
  static const int kSearchTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 search_type() const;
  inline void set_search_type(::google::protobuf::uint32 value);

  // required uint32 search_reault = 3;
  inline bool has_search_reault() const;
  inline void clear_search_reault();
  static const int kSearchReaultFieldNumber = 3;
  inline ::google::protobuf::uint32 search_reault() const;
  inline void set_search_reault(::google::protobuf::uint32 value);

  // required uint32 search_seq = 4;
  inline bool has_search_seq() const;
  inline void clear_search_seq();
  static const int kSearchSeqFieldNumber = 4;
  inline ::google::protobuf::uint32 search_seq() const;
  inline void set_search_seq(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.UserInfo user_info_list = 5;
  inline int user_info_list_size() const;
  inline void clear_user_info_list();
  static const int kUserInfoListFieldNumber = 5;
  inline const ::IM::BaseDefine::UserInfo& user_info_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_info_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserSearchRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_search_type();
  inline void clear_has_search_type();
  inline void set_has_search_reault();
  inline void clear_has_search_reault();
  inline void set_has_search_seq();
  inline void clear_has_search_seq();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 search_type_;
  ::google::protobuf::uint32 search_reault_;
  ::google::protobuf::uint32 search_seq_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_info_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserSearchRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserAddFriendReq : public ::google::protobuf::MessageLite {
 public:
  IMUserAddFriendReq();
  virtual ~IMUserAddFriendReq();

  IMUserAddFriendReq(const IMUserAddFriendReq& from);

  inline IMUserAddFriendReq& operator=(const IMUserAddFriendReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserAddFriendReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserAddFriendReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserAddFriendReq* other);

  // implements Message ----------------------------------------------

  IMUserAddFriendReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserAddFriendReq& from);
  void MergeFrom(const IMUserAddFriendReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 add_id = 2;
  inline bool has_add_id() const;
  inline void clear_add_id();
  static const int kAddIdFieldNumber = 2;
  inline ::google::protobuf::uint32 add_id() const;
  inline void set_add_id(::google::protobuf::uint32 value);

  // optional string str_valid = 3;
  inline bool has_str_valid() const;
  inline void clear_str_valid();
  static const int kStrValidFieldNumber = 3;
  inline const ::std::string& str_valid() const;
  inline void set_str_valid(const ::std::string& value);
  inline void set_str_valid(const char* value);
  inline void set_str_valid(const char* value, size_t size);
  inline ::std::string* mutable_str_valid();
  inline ::std::string* release_str_valid();
  inline void set_allocated_str_valid(::std::string* str_valid);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserAddFriendReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_add_id();
  inline void clear_has_add_id();
  inline void set_has_str_valid();
  inline void clear_has_str_valid();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 add_id_;
  ::std::string* str_valid_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserAddFriendReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUserAddFriendRsp : public ::google::protobuf::MessageLite {
 public:
  IMUserAddFriendRsp();
  virtual ~IMUserAddFriendRsp();

  IMUserAddFriendRsp(const IMUserAddFriendRsp& from);

  inline IMUserAddFriendRsp& operator=(const IMUserAddFriendRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserAddFriendRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserAddFriendRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserAddFriendRsp* other);

  // implements Message ----------------------------------------------

  IMUserAddFriendRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserAddFriendRsp& from);
  void MergeFrom(const IMUserAddFriendRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 add_id = 2;
  inline bool has_add_id() const;
  inline void clear_add_id();
  static const int kAddIdFieldNumber = 2;
  inline ::google::protobuf::uint32 add_id() const;
  inline void set_add_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 3;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required string result_des = 4;
  inline bool has_result_des() const;
  inline void clear_result_des();
  static const int kResultDesFieldNumber = 4;
  inline const ::std::string& result_des() const;
  inline void set_result_des(const ::std::string& value);
  inline void set_result_des(const char* value);
  inline void set_result_des(const char* value, size_t size);
  inline ::std::string* mutable_result_des();
  inline ::std::string* release_result_des();
  inline void set_allocated_result_des(::std::string* result_des);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserAddFriendRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_add_id();
  inline void clear_has_add_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_result_des();
  inline void clear_has_result_des();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 add_id_;
  ::std::string* result_des_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserAddFriendRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserRemFriendReq : public ::google::protobuf::MessageLite {
 public:
  IMUserRemFriendReq();
  virtual ~IMUserRemFriendReq();

  IMUserRemFriendReq(const IMUserRemFriendReq& from);

  inline IMUserRemFriendReq& operator=(const IMUserRemFriendReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserRemFriendReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserRemFriendReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserRemFriendReq* other);

  // implements Message ----------------------------------------------

  IMUserRemFriendReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserRemFriendReq& from);
  void MergeFrom(const IMUserRemFriendReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 remove_id = 2;
  inline bool has_remove_id() const;
  inline void clear_remove_id();
  static const int kRemoveIdFieldNumber = 2;
  inline ::google::protobuf::uint32 remove_id() const;
  inline void set_remove_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserRemFriendReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_remove_id();
  inline void clear_has_remove_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 remove_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserRemFriendReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUserRemFriendRsp : public ::google::protobuf::MessageLite {
 public:
  IMUserRemFriendRsp();
  virtual ~IMUserRemFriendRsp();

  IMUserRemFriendRsp(const IMUserRemFriendRsp& from);

  inline IMUserRemFriendRsp& operator=(const IMUserRemFriendRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserRemFriendRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserRemFriendRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserRemFriendRsp* other);

  // implements Message ----------------------------------------------

  IMUserRemFriendRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserRemFriendRsp& from);
  void MergeFrom(const IMUserRemFriendRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required uint32 rm_id = 3;
  inline bool has_rm_id() const;
  inline void clear_rm_id();
  static const int kRmIdFieldNumber = 3;
  inline ::google::protobuf::uint32 rm_id() const;
  inline void set_rm_id(::google::protobuf::uint32 value);

  // required string result_string = 4;
  inline bool has_result_string() const;
  inline void clear_result_string();
  static const int kResultStringFieldNumber = 4;
  inline const ::std::string& result_string() const;
  inline void set_result_string(const ::std::string& value);
  inline void set_result_string(const char* value);
  inline void set_result_string(const char* value, size_t size);
  inline ::std::string* mutable_result_string();
  inline ::std::string* release_result_string();
  inline void set_allocated_result_string(::std::string* result_string);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserRemFriendRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_rm_id();
  inline void clear_has_rm_id();
  inline void set_has_result_string();
  inline void clear_has_result_string();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* result_string_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 rm_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserRemFriendRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserInfoChangeReq : public ::google::protobuf::MessageLite {
 public:
  IMUserInfoChangeReq();
  virtual ~IMUserInfoChangeReq();

  IMUserInfoChangeReq(const IMUserInfoChangeReq& from);

  inline IMUserInfoChangeReq& operator=(const IMUserInfoChangeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserInfoChangeReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserInfoChangeReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserInfoChangeReq* other);

  // implements Message ----------------------------------------------

  IMUserInfoChangeReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserInfoChangeReq& from);
  void MergeFrom(const IMUserInfoChangeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 change_type = 2;
  inline bool has_change_type() const;
  inline void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 change_type() const;
  inline void set_change_type(::google::protobuf::uint32 value);

  // required string change_content = 3;
  inline bool has_change_content() const;
  inline void clear_change_content();
  static const int kChangeContentFieldNumber = 3;
  inline const ::std::string& change_content() const;
  inline void set_change_content(const ::std::string& value);
  inline void set_change_content(const char* value);
  inline void set_change_content(const char* value, size_t size);
  inline ::std::string* mutable_change_content();
  inline ::std::string* release_change_content();
  inline void set_allocated_change_content(::std::string* change_content);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserInfoChangeReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_change_type();
  inline void clear_has_change_type();
  inline void set_has_change_content();
  inline void clear_has_change_content();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 change_type_;
  ::std::string* change_content_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserInfoChangeReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUserInfoChangeRsp : public ::google::protobuf::MessageLite {
 public:
  IMUserInfoChangeRsp();
  virtual ~IMUserInfoChangeRsp();

  IMUserInfoChangeRsp(const IMUserInfoChangeRsp& from);

  inline IMUserInfoChangeRsp& operator=(const IMUserInfoChangeRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserInfoChangeRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserInfoChangeRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserInfoChangeRsp* other);

  // implements Message ----------------------------------------------

  IMUserInfoChangeRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserInfoChangeRsp& from);
  void MergeFrom(const IMUserInfoChangeRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required string result_des = 3;
  inline bool has_result_des() const;
  inline void clear_result_des();
  static const int kResultDesFieldNumber = 3;
  inline const ::std::string& result_des() const;
  inline void set_result_des(const ::std::string& value);
  inline void set_result_des(const char* value);
  inline void set_result_des(const char* value, size_t size);
  inline ::std::string* mutable_result_des();
  inline ::std::string* release_result_des();
  inline void set_allocated_result_des(::std::string* result_des);

  // required uint32 change_type = 4;
  inline bool has_change_type() const;
  inline void clear_change_type();
  static const int kChangeTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 change_type() const;
  inline void set_change_type(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserInfoChangeRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_result_des();
  inline void clear_has_result_des();
  inline void set_has_change_type();
  inline void clear_has_change_type();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* result_des_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 change_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserInfoChangeRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserAddFriendToUserRsp : public ::google::protobuf::MessageLite {
 public:
  IMUserAddFriendToUserRsp();
  virtual ~IMUserAddFriendToUserRsp();

  IMUserAddFriendToUserRsp(const IMUserAddFriendToUserRsp& from);

  inline IMUserAddFriendToUserRsp& operator=(const IMUserAddFriendToUserRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserAddFriendToUserRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserAddFriendToUserRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserAddFriendToUserRsp* other);

  // implements Message ----------------------------------------------

  IMUserAddFriendToUserRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserAddFriendToUserRsp& from);
  void MergeFrom(const IMUserAddFriendToUserRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 from_id = 2;
  inline bool has_from_id() const;
  inline void clear_from_id();
  static const int kFromIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_id() const;
  inline void set_from_id(::google::protobuf::uint32 value);

  // required uint32 msg_id = 3;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserInfo user_info = 4;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 4;
  inline const ::IM::BaseDefine::UserInfo& user_info() const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info();
  inline ::IM::BaseDefine::UserInfo* release_user_info();
  inline void set_allocated_user_info(::IM::BaseDefine::UserInfo* user_info);

  // required .IM.BaseDefine.SessionType msg_type = 5;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 5;
  inline ::IM::BaseDefine::SessionType msg_type() const;
  inline void set_msg_type(::IM::BaseDefine::SessionType value);

  // required .IM.BaseDefine.AddFriendStatus status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::IM::BaseDefine::AddFriendStatus status() const;
  inline void set_status(::IM::BaseDefine::AddFriendStatus value);

  // required uint32 create_time = 7;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // optional string content = 8;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 8;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserAddFriendToUserRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_from_id();
  inline void clear_has_from_id();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 from_id_;
  ::IM::BaseDefine::UserInfo* user_info_;
  ::google::protobuf::uint32 msg_id_;
  int msg_type_;
  int status_;
  ::google::protobuf::uint32 create_time_;
  ::std::string* content_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserAddFriendToUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserAddFriendTargetReq : public ::google::protobuf::MessageLite {
 public:
  IMUserAddFriendTargetReq();
  virtual ~IMUserAddFriendTargetReq();

  IMUserAddFriendTargetReq(const IMUserAddFriendTargetReq& from);

  inline IMUserAddFriendTargetReq& operator=(const IMUserAddFriendTargetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserAddFriendTargetReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserAddFriendTargetReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserAddFriendTargetReq* other);

  // implements Message ----------------------------------------------

  IMUserAddFriendTargetReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserAddFriendTargetReq& from);
  void MergeFrom(const IMUserAddFriendTargetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 from_id = 2;
  inline bool has_from_id() const;
  inline void clear_from_id();
  static const int kFromIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_id() const;
  inline void set_from_id(::google::protobuf::uint32 value);

  // required uint32 msg_id = 3;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.AddFriendStatus status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::IM::BaseDefine::AddFriendStatus status() const;
  inline void set_status(::IM::BaseDefine::AddFriendStatus value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserAddFriendTargetReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_from_id();
  inline void clear_has_from_id();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 from_id_;
  ::google::protobuf::uint32 msg_id_;
  int status_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserAddFriendTargetReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUserAddFriendTargetRsp : public ::google::protobuf::MessageLite {
 public:
  IMUserAddFriendTargetRsp();
  virtual ~IMUserAddFriendTargetRsp();

  IMUserAddFriendTargetRsp(const IMUserAddFriendTargetRsp& from);

  inline IMUserAddFriendTargetRsp& operator=(const IMUserAddFriendTargetRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserAddFriendTargetRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserAddFriendTargetRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserAddFriendTargetRsp* other);

  // implements Message ----------------------------------------------

  IMUserAddFriendTargetRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserAddFriendTargetRsp& from);
  void MergeFrom(const IMUserAddFriendTargetRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 from_id = 2;
  inline bool has_from_id() const;
  inline void clear_from_id();
  static const int kFromIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_id() const;
  inline void set_from_id(::google::protobuf::uint32 value);

  // required uint32 msg_id = 3;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.AddFriendStatus status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::IM::BaseDefine::AddFriendStatus status() const;
  inline void set_status(::IM::BaseDefine::AddFriendStatus value);

  // required uint32 result_code = 5;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 5;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required string result_des = 6;
  inline bool has_result_des() const;
  inline void clear_result_des();
  static const int kResultDesFieldNumber = 6;
  inline const ::std::string& result_des() const;
  inline void set_result_des(const ::std::string& value);
  inline void set_result_des(const char* value);
  inline void set_result_des(const char* value, size_t size);
  inline ::std::string* mutable_result_des();
  inline ::std::string* release_result_des();
  inline void set_allocated_result_des(::std::string* result_des);

  // required .IM.BaseDefine.UserInfo user_info = 7;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 7;
  inline const ::IM::BaseDefine::UserInfo& user_info() const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info();
  inline ::IM::BaseDefine::UserInfo* release_user_info();
  inline void set_allocated_user_info(::IM::BaseDefine::UserInfo* user_info);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserAddFriendTargetRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_from_id();
  inline void clear_has_from_id();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_result_des();
  inline void clear_has_result_des();
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 from_id_;
  ::google::protobuf::uint32 msg_id_;
  int status_;
  ::std::string* result_des_;
  ::IM::BaseDefine::UserInfo* user_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserAddFriendTargetRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserAddFriendToSelfRsp : public ::google::protobuf::MessageLite {
 public:
  IMUserAddFriendToSelfRsp();
  virtual ~IMUserAddFriendToSelfRsp();

  IMUserAddFriendToSelfRsp(const IMUserAddFriendToSelfRsp& from);

  inline IMUserAddFriendToSelfRsp& operator=(const IMUserAddFriendToSelfRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserAddFriendToSelfRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserAddFriendToSelfRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserAddFriendToSelfRsp* other);

  // implements Message ----------------------------------------------

  IMUserAddFriendToSelfRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserAddFriendToSelfRsp& from);
  void MergeFrom(const IMUserAddFriendToSelfRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 from_id = 2;
  inline bool has_from_id() const;
  inline void clear_from_id();
  static const int kFromIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_id() const;
  inline void set_from_id(::google::protobuf::uint32 value);

  // required uint32 msg_id = 3;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserInfo user_info = 4;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 4;
  inline const ::IM::BaseDefine::UserInfo& user_info() const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info();
  inline ::IM::BaseDefine::UserInfo* release_user_info();
  inline void set_allocated_user_info(::IM::BaseDefine::UserInfo* user_info);

  // required .IM.BaseDefine.SessionType msg_type = 5;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 5;
  inline ::IM::BaseDefine::SessionType msg_type() const;
  inline void set_msg_type(::IM::BaseDefine::SessionType value);

  // required uint32 create_time = 6;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.AddFriendStatus status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::IM::BaseDefine::AddFriendStatus status() const;
  inline void set_status(::IM::BaseDefine::AddFriendStatus value);

  // required string result_des = 8;
  inline bool has_result_des() const;
  inline void clear_result_des();
  static const int kResultDesFieldNumber = 8;
  inline const ::std::string& result_des() const;
  inline void set_result_des(const ::std::string& value);
  inline void set_result_des(const char* value);
  inline void set_result_des(const char* value, size_t size);
  inline ::std::string* mutable_result_des();
  inline ::std::string* release_result_des();
  inline void set_allocated_result_des(::std::string* result_des);

  // optional string content = 9;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 9;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserAddFriendToSelfRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_from_id();
  inline void clear_has_from_id();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_result_des();
  inline void clear_has_result_des();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 from_id_;
  ::IM::BaseDefine::UserInfo* user_info_;
  ::google::protobuf::uint32 msg_id_;
  int msg_type_;
  ::google::protobuf::uint32 create_time_;
  int status_;
  ::std::string* result_des_;
  ::std::string* content_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMUserAddFriendToSelfRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMSendDelMsgToTargetRsp : public ::google::protobuf::MessageLite {
 public:
  IMSendDelMsgToTargetRsp();
  virtual ~IMSendDelMsgToTargetRsp();

  IMSendDelMsgToTargetRsp(const IMSendDelMsgToTargetRsp& from);

  inline IMSendDelMsgToTargetRsp& operator=(const IMSendDelMsgToTargetRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSendDelMsgToTargetRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSendDelMsgToTargetRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSendDelMsgToTargetRsp* other);

  // implements Message ----------------------------------------------

  IMSendDelMsgToTargetRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSendDelMsgToTargetRsp& from);
  void MergeFrom(const IMSendDelMsgToTargetRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 from_id = 2;
  inline bool has_from_id() const;
  inline void clear_from_id();
  static const int kFromIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_id() const;
  inline void set_from_id(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Buddy.IMSendDelMsgToTargetRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_from_id();
  inline void clear_has_from_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 from_id_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

  void InitAsDefaultInstance();
  static IMSendDelMsgToTargetRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// IMRecentContactSessionReq

// required uint32 user_id = 1;
inline bool IMRecentContactSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.user_id)
  return user_id_;
}
inline void IMRecentContactSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMRecentContactSessionReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRecentContactSessionReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRecentContactSessionReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRecentContactSessionReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.latest_update_time)
  return latest_update_time_;
}
inline void IMRecentContactSessionReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionReq.attach_data)
  return *attach_data_;
}
inline void IMRecentContactSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline void IMRecentContactSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline void IMRecentContactSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecentContactSessionReq.attach_data)
}
inline ::std::string* IMRecentContactSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecentContactSessionReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecentContactSessionReq.attach_data)
}

// -------------------------------------------------------------------

// IMRecentContactSessionRsp

// required uint32 user_id = 1;
inline bool IMRecentContactSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.user_id)
  return user_id_;
}
inline void IMRecentContactSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionRsp.user_id)
}

// repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
inline int IMRecentContactSessionRsp::contact_session_list_size() const {
  return contact_session_list_.size();
}
inline void IMRecentContactSessionRsp::clear_contact_session_list() {
  contact_session_list_.Clear();
}
inline const ::IM::BaseDefine::ContactSessionInfo& IMRecentContactSessionRsp::contact_session_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Get(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::mutable_contact_session_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Mutable(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::add_contact_session_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
IMRecentContactSessionRsp::contact_session_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return contact_session_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
IMRecentContactSessionRsp::mutable_contact_session_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMRecentContactSessionRsp.contact_session_list)
  return &contact_session_list_;
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRecentContactSessionRsp.attach_data)
  return *attach_data_;
}
inline void IMRecentContactSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline void IMRecentContactSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline void IMRecentContactSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}
inline ::std::string* IMRecentContactSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRecentContactSessionRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRecentContactSessionRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRecentContactSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserStatNotify

// required .IM.BaseDefine.UserStat user_stat = 1;
inline bool IMUserStatNotify::has_user_stat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserStatNotify::set_has_user_stat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserStatNotify::clear_has_user_stat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserStatNotify::clear_user_stat() {
  if (user_stat_ != NULL) user_stat_->::IM::BaseDefine::UserStat::Clear();
  clear_has_user_stat();
}
inline const ::IM::BaseDefine::UserStat& IMUserStatNotify::user_stat() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserStatNotify.user_stat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_stat_ != NULL ? *user_stat_ : *default_instance().user_stat_;
#else
  return user_stat_ != NULL ? *user_stat_ : *default_instance_->user_stat_;
#endif
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::mutable_user_stat() {
  set_has_user_stat();
  if (user_stat_ == NULL) user_stat_ = new ::IM::BaseDefine::UserStat;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserStatNotify.user_stat)
  return user_stat_;
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::release_user_stat() {
  clear_has_user_stat();
  ::IM::BaseDefine::UserStat* temp = user_stat_;
  user_stat_ = NULL;
  return temp;
}
inline void IMUserStatNotify::set_allocated_user_stat(::IM::BaseDefine::UserStat* user_stat) {
  delete user_stat_;
  user_stat_ = user_stat;
  if (user_stat) {
    set_has_user_stat();
  } else {
    clear_has_user_stat();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserStatNotify.user_stat)
}

// -------------------------------------------------------------------

// IMUsersInfoReq

// required uint32 user_id = 1;
inline bool IMUsersInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.user_id)
  return user_id_;
}
inline void IMUsersInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int IMUsersInfoReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersInfoReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.user_id_list)
  return user_id_list_.Get(index);
}
inline void IMUsersInfoReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.user_id_list)
}
inline void IMUsersInfoReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersInfoReq.user_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersInfoReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersInfoReq.user_id_list)
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersInfoReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersInfoReq.user_id_list)
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoReq.attach_data)
  return *attach_data_;
}
inline void IMUsersInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline void IMUsersInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline void IMUsersInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersInfoReq.attach_data)
}
inline ::std::string* IMUsersInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMUsersInfoRsp

// required uint32 user_id = 1;
inline bool IMUsersInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.user_id)
  return user_id_;
}
inline void IMUsersInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoRsp.user_id)
}

// repeated .IM.BaseDefine.UserInfo user_info_list = 2;
inline int IMUsersInfoRsp::user_info_list_size() const {
  return user_info_list_.size();
}
inline void IMUsersInfoRsp::clear_user_info_list() {
  user_info_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMUsersInfoRsp::user_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::mutable_user_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::add_user_info_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMUsersInfoRsp::user_info_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return user_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMUsersInfoRsp::mutable_user_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersInfoRsp.user_info_list)
  return &user_info_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMUsersInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline void IMUsersInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline void IMUsersInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersInfoRsp.attach_data)
}
inline ::std::string* IMUsersInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMRemoveSessionReq

// required uint32 user_id = 1;
inline bool IMRemoveSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.user_id)
  return user_id_;
}
inline void IMRemoveSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.user_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionReq::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionReq::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionReq::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionReq::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionReq::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.session_type)
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionReq::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.session_id)
  return session_id_;
}
inline void IMRemoveSessionReq::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.session_id)
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionReq.attach_data)
  return *attach_data_;
}
inline void IMRemoveSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline void IMRemoveSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline void IMRemoveSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRemoveSessionReq.attach_data)
}
inline ::std::string* IMRemoveSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRemoveSessionReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMRemoveSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRemoveSessionReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRemoveSessionReq.attach_data)
}

// -------------------------------------------------------------------

// IMRemoveSessionRsp

// required uint32 user_id = 1;
inline bool IMRemoveSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.user_id)
  return user_id_;
}
inline void IMRemoveSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMRemoveSessionRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.result_code)
  return result_code_;
}
inline void IMRemoveSessionRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.result_code)
}

// required .IM.BaseDefine.SessionType session_type = 3;
inline bool IMRemoveSessionRsp::has_session_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionRsp::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionRsp::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionRsp::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionRsp::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.session_type)
}

// required uint32 session_id = 4;
inline bool IMRemoveSessionRsp::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionRsp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionRsp::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.session_id)
  return session_id_;
}
inline void IMRemoveSessionRsp::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.session_id)
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRemoveSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRemoveSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRemoveSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionRsp.attach_data)
  return *attach_data_;
}
inline void IMRemoveSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline void IMRemoveSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline void IMRemoveSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMRemoveSessionRsp.attach_data)
}
inline ::std::string* IMRemoveSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMRemoveSessionRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMRemoveSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMRemoveSessionRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMRemoveSessionRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAllUserReq

// required uint32 user_id = 1;
inline bool IMAllUserReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.user_id)
  return user_id_;
}
inline void IMAllUserReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.latest_update_time)
  return latest_update_time_;
}
inline void IMAllUserReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMAllUserReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAllUserReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAllUserReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAllUserReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserReq.attach_data)
  return *attach_data_;
}
inline void IMAllUserReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserReq.attach_data)
}
inline void IMAllUserReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAllUserReq.attach_data)
}
inline void IMAllUserReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAllUserReq.attach_data)
}
inline ::std::string* IMAllUserReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMAllUserReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAllUserReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAllUserReq.attach_data)
}

// -------------------------------------------------------------------

// IMAllUserRsp

// required uint32 user_id = 1;
inline bool IMAllUserRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.user_id)
  return user_id_;
}
inline void IMAllUserRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.latest_update_time)
  return latest_update_time_;
}
inline void IMAllUserRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.latest_update_time)
}

// repeated .IM.BaseDefine.UserInfo user_list = 3;
inline int IMAllUserRsp::user_list_size() const {
  return user_list_.size();
}
inline void IMAllUserRsp::clear_user_list() {
  user_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMAllUserRsp::user_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::add_user_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMAllUserRsp::user_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMAllUserRsp.user_list)
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMAllUserRsp::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMAllUserRsp.user_list)
  return &user_list_;
}

// optional bytes attach_data = 20;
inline bool IMAllUserRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAllUserRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAllUserRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAllUserRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAllUserRsp.attach_data)
  return *attach_data_;
}
inline void IMAllUserRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAllUserRsp.attach_data)
}
inline void IMAllUserRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAllUserRsp.attach_data)
}
inline void IMAllUserRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAllUserRsp.attach_data)
}
inline ::std::string* IMAllUserRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAllUserRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMAllUserRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAllUserRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAllUserRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUsersStatReq

// required uint32 user_id = 1;
inline bool IMUsersStatReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.user_id)
  return user_id_;
}
inline void IMUsersStatReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.user_id)
}

// repeated uint32 user_id_list = 2;
inline int IMUsersStatReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersStatReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.user_id_list)
  return user_id_list_.Get(index);
}
inline void IMUsersStatReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.user_id_list)
}
inline void IMUsersStatReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersStatReq.user_id_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersStatReq::user_id_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersStatReq.user_id_list)
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersStatReq::mutable_user_id_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersStatReq.user_id_list)
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatReq.attach_data)
  return *attach_data_;
}
inline void IMUsersStatReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatReq.attach_data)
}
inline void IMUsersStatReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersStatReq.attach_data)
}
inline void IMUsersStatReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersStatReq.attach_data)
}
inline ::std::string* IMUsersStatReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersStatReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersStatReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersStatReq.attach_data)
}

// -------------------------------------------------------------------

// IMUsersStatRsp

// required uint32 user_id = 1;
inline bool IMUsersStatRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.user_id)
  return user_id_;
}
inline void IMUsersStatRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatRsp.user_id)
}

// repeated .IM.BaseDefine.UserStat user_stat_list = 2;
inline int IMUsersStatRsp::user_stat_list_size() const {
  return user_stat_list_.size();
}
inline void IMUsersStatRsp::clear_user_stat_list() {
  user_stat_list_.Clear();
}
inline const ::IM::BaseDefine::UserStat& IMUsersStatRsp::user_stat_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Get(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::mutable_user_stat_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::add_user_stat_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
IMUsersStatRsp::user_stat_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return user_stat_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
IMUsersStatRsp::mutable_user_stat_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUsersStatRsp.user_stat_list)
  return &user_stat_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUsersStatRsp.attach_data)
  return *attach_data_;
}
inline void IMUsersStatRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline void IMUsersStatRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline void IMUsersStatRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUsersStatRsp.attach_data)
}
inline ::std::string* IMUsersStatRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUsersStatRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUsersStatRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUsersStatRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUsersStatRsp.attach_data)
}

// -------------------------------------------------------------------

// IMChangeAvatarReq

// required uint32 user_id = 1;
inline bool IMChangeAvatarReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.user_id)
  return user_id_;
}
inline void IMChangeAvatarReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.user_id)
}

// required string avatar_url = 2;
inline bool IMChangeAvatarReq::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarReq::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarReq::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarReq::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& IMChangeAvatarReq::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.avatar_url)
  return *avatar_url_;
}
inline void IMChangeAvatarReq::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarReq.avatar_url)
}
inline ::std::string* IMChangeAvatarReq::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarReq.avatar_url)
  return avatar_url_;
}
inline ::std::string* IMChangeAvatarReq::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarReq::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarReq.avatar_url)
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarReq.attach_data)
  return *attach_data_;
}
inline void IMChangeAvatarReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline void IMChangeAvatarReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline void IMChangeAvatarReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarReq.attach_data)
}
inline ::std::string* IMChangeAvatarReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeAvatarReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarReq.attach_data)
}

// -------------------------------------------------------------------

// IMChangeAvatarRsp

// required uint32 user_id = 1;
inline bool IMChangeAvatarRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.user_id)
  return user_id_;
}
inline void IMChangeAvatarRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMChangeAvatarRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.result_code)
  return result_code_;
}
inline void IMChangeAvatarRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.result_code)
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeAvatarRsp.attach_data)
  return *attach_data_;
}
inline void IMChangeAvatarRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline void IMChangeAvatarRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline void IMChangeAvatarRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeAvatarRsp.attach_data)
}
inline ::std::string* IMChangeAvatarRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeAvatarRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeAvatarRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeAvatarRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeAvatarRsp.attach_data)
}

// -------------------------------------------------------------------

// IMPCLoginStatusNotify

// required uint32 user_id = 1;
inline bool IMPCLoginStatusNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMPCLoginStatusNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMPCLoginStatusNotify.user_id)
  return user_id_;
}
inline void IMPCLoginStatusNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMPCLoginStatusNotify.user_id)
}

// required .IM.BaseDefine.UserStatType login_stat = 2;
inline bool IMPCLoginStatusNotify::has_login_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_login_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_has_login_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_login_stat() {
  login_stat_ = 0;
  clear_has_login_stat();
}
inline ::IM::BaseDefine::UserStatType IMPCLoginStatusNotify::login_stat() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMPCLoginStatusNotify.login_stat)
  return static_cast< ::IM::BaseDefine::UserStatType >(login_stat_);
}
inline void IMPCLoginStatusNotify::set_login_stat(::IM::BaseDefine::UserStatType value) {
  assert(::IM::BaseDefine::UserStatType_IsValid(value));
  set_has_login_stat();
  login_stat_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMPCLoginStatusNotify.login_stat)
}

// -------------------------------------------------------------------

// IMRemoveSessionNotify

// required uint32 user_id = 1;
inline bool IMRemoveSessionNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.user_id)
  return user_id_;
}
inline void IMRemoveSessionNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.user_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionNotify::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionNotify::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionNotify::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType IMRemoveSessionNotify::session_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionNotify::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.session_type)
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionNotify::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionNotify::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionNotify::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::session_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMRemoveSessionNotify.session_id)
  return session_id_;
}
inline void IMRemoveSessionNotify::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMRemoveSessionNotify.session_id)
}

// -------------------------------------------------------------------

// IMDepartmentReq

// required uint32 user_id = 1;
inline bool IMDepartmentReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.user_id)
  return user_id_;
}
inline void IMDepartmentReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentReq::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.latest_update_time)
  return latest_update_time_;
}
inline void IMDepartmentReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.latest_update_time)
}

// optional bytes attach_data = 20;
inline bool IMDepartmentReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMDepartmentReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMDepartmentReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMDepartmentReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentReq.attach_data)
  return *attach_data_;
}
inline void IMDepartmentReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentReq.attach_data)
}
inline void IMDepartmentReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDepartmentReq.attach_data)
}
inline void IMDepartmentReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDepartmentReq.attach_data)
}
inline ::std::string* IMDepartmentReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMDepartmentReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDepartmentReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDepartmentReq.attach_data)
}

// -------------------------------------------------------------------

// IMDepartmentRsp

// required uint32 user_id = 1;
inline bool IMDepartmentRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.user_id)
  return user_id_;
}
inline void IMDepartmentRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.user_id)
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::latest_update_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.latest_update_time)
  return latest_update_time_;
}
inline void IMDepartmentRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.latest_update_time)
}

// repeated .IM.BaseDefine.DepartInfo dept_list = 3;
inline int IMDepartmentRsp::dept_list_size() const {
  return dept_list_.size();
}
inline void IMDepartmentRsp::clear_dept_list() {
  dept_list_.Clear();
}
inline const ::IM::BaseDefine::DepartInfo& IMDepartmentRsp::dept_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Get(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::mutable_dept_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Mutable(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::add_dept_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
IMDepartmentRsp::dept_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMDepartmentRsp.dept_list)
  return dept_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
IMDepartmentRsp::mutable_dept_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMDepartmentRsp.dept_list)
  return &dept_list_;
}

// optional bytes attach_data = 20;
inline bool IMDepartmentRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMDepartmentRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMDepartmentRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMDepartmentRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMDepartmentRsp.attach_data)
  return *attach_data_;
}
inline void IMDepartmentRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline void IMDepartmentRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline void IMDepartmentRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMDepartmentRsp.attach_data)
}
inline ::std::string* IMDepartmentRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMDepartmentRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMDepartmentRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMDepartmentRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMDepartmentRsp.attach_data)
}

// -------------------------------------------------------------------

// IMAvatarChangedNotify

// required uint32 changed_user_id = 1;
inline bool IMAvatarChangedNotify::has_changed_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAvatarChangedNotify::set_has_changed_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAvatarChangedNotify::clear_has_changed_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAvatarChangedNotify::clear_changed_user_id() {
  changed_user_id_ = 0u;
  clear_has_changed_user_id();
}
inline ::google::protobuf::uint32 IMAvatarChangedNotify::changed_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAvatarChangedNotify.changed_user_id)
  return changed_user_id_;
}
inline void IMAvatarChangedNotify::set_changed_user_id(::google::protobuf::uint32 value) {
  set_has_changed_user_id();
  changed_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAvatarChangedNotify.changed_user_id)
}

// required string avatar_url = 2;
inline bool IMAvatarChangedNotify::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAvatarChangedNotify::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAvatarChangedNotify::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAvatarChangedNotify::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& IMAvatarChangedNotify::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMAvatarChangedNotify.avatar_url)
  return *avatar_url_;
}
inline void IMAvatarChangedNotify::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline void IMAvatarChangedNotify::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline void IMAvatarChangedNotify::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}
inline ::std::string* IMAvatarChangedNotify::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMAvatarChangedNotify.avatar_url)
  return avatar_url_;
}
inline ::std::string* IMAvatarChangedNotify::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMAvatarChangedNotify::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMAvatarChangedNotify.avatar_url)
}

// -------------------------------------------------------------------

// IMChangeSignInfoReq

// required uint32 user_id = 1;
inline bool IMChangeSignInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeSignInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeSignInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeSignInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeSignInfoReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.user_id)
  return user_id_;
}
inline void IMChangeSignInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.user_id)
}

// required string sign_info = 2;
inline bool IMChangeSignInfoReq::has_sign_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeSignInfoReq::set_has_sign_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeSignInfoReq::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeSignInfoReq::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMChangeSignInfoReq::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.sign_info)
  return *sign_info_;
}
inline void IMChangeSignInfoReq::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline void IMChangeSignInfoReq::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline void IMChangeSignInfoReq::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoReq.sign_info)
}
inline ::std::string* IMChangeSignInfoReq::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoReq.sign_info)
  return sign_info_;
}
inline ::std::string* IMChangeSignInfoReq::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoReq::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoReq.sign_info)
}

// optional bytes attach_data = 20;
inline bool IMChangeSignInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeSignInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeSignInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeSignInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeSignInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoReq.attach_data)
  return *attach_data_;
}
inline void IMChangeSignInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline void IMChangeSignInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline void IMChangeSignInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoReq.attach_data)
}
inline ::std::string* IMChangeSignInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeSignInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMChangeSignInfoRsp

// required uint32 user_id = 1;
inline bool IMChangeSignInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeSignInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeSignInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeSignInfoRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.user_id)
  return user_id_;
}
inline void IMChangeSignInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMChangeSignInfoRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeSignInfoRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeSignInfoRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMChangeSignInfoRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.result_code)
  return result_code_;
}
inline void IMChangeSignInfoRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.result_code)
}

// optional string sign_info = 3;
inline bool IMChangeSignInfoRsp::has_sign_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_sign_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeSignInfoRsp::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeSignInfoRsp::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMChangeSignInfoRsp::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.sign_info)
  return *sign_info_;
}
inline void IMChangeSignInfoRsp::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline void IMChangeSignInfoRsp::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline void IMChangeSignInfoRsp::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}
inline ::std::string* IMChangeSignInfoRsp::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoRsp.sign_info)
  return sign_info_;
}
inline ::std::string* IMChangeSignInfoRsp::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoRsp::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoRsp.sign_info)
}

// optional bytes attach_data = 20;
inline bool IMChangeSignInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMChangeSignInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMChangeSignInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMChangeSignInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeSignInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMChangeSignInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMChangeSignInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline void IMChangeSignInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline void IMChangeSignInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}
inline ::std::string* IMChangeSignInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMChangeSignInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMChangeSignInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMChangeSignInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMChangeSignInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMSignInfoChangedNotify

// required uint32 changed_user_id = 1;
inline bool IMSignInfoChangedNotify::has_changed_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSignInfoChangedNotify::set_has_changed_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSignInfoChangedNotify::clear_has_changed_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSignInfoChangedNotify::clear_changed_user_id() {
  changed_user_id_ = 0u;
  clear_has_changed_user_id();
}
inline ::google::protobuf::uint32 IMSignInfoChangedNotify::changed_user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSignInfoChangedNotify.changed_user_id)
  return changed_user_id_;
}
inline void IMSignInfoChangedNotify::set_changed_user_id(::google::protobuf::uint32 value) {
  set_has_changed_user_id();
  changed_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSignInfoChangedNotify.changed_user_id)
}

// required string sign_info = 2;
inline bool IMSignInfoChangedNotify::has_sign_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSignInfoChangedNotify::set_has_sign_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSignInfoChangedNotify::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSignInfoChangedNotify::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& IMSignInfoChangedNotify::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSignInfoChangedNotify.sign_info)
  return *sign_info_;
}
inline void IMSignInfoChangedNotify::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline void IMSignInfoChangedNotify::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline void IMSignInfoChangedNotify::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}
inline ::std::string* IMSignInfoChangedNotify::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMSignInfoChangedNotify.sign_info)
  return sign_info_;
}
inline ::std::string* IMSignInfoChangedNotify::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSignInfoChangedNotify::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMSignInfoChangedNotify.sign_info)
}

// -------------------------------------------------------------------

// IMUserSearchReq

// required uint32 user_id = 1;
inline bool IMUserSearchReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserSearchReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserSearchReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserSearchReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserSearchReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchReq.user_id)
  return user_id_;
}
inline void IMUserSearchReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchReq.user_id)
}

// required string user_name = 2;
inline bool IMUserSearchReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserSearchReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserSearchReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserSearchReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& IMUserSearchReq::user_name() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchReq.user_name)
  return *user_name_;
}
inline void IMUserSearchReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchReq.user_name)
}
inline void IMUserSearchReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserSearchReq.user_name)
}
inline void IMUserSearchReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserSearchReq.user_name)
}
inline ::std::string* IMUserSearchReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserSearchReq.user_name)
  return user_name_;
}
inline ::std::string* IMUserSearchReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserSearchReq::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserSearchReq.user_name)
}

// required uint32 search_type = 3;
inline bool IMUserSearchReq::has_search_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserSearchReq::set_has_search_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserSearchReq::clear_has_search_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserSearchReq::clear_search_type() {
  search_type_ = 0u;
  clear_has_search_type();
}
inline ::google::protobuf::uint32 IMUserSearchReq::search_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchReq.search_type)
  return search_type_;
}
inline void IMUserSearchReq::set_search_type(::google::protobuf::uint32 value) {
  set_has_search_type();
  search_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchReq.search_type)
}

// required uint32 search_seq = 4;
inline bool IMUserSearchReq::has_search_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserSearchReq::set_has_search_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserSearchReq::clear_has_search_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserSearchReq::clear_search_seq() {
  search_seq_ = 0u;
  clear_has_search_seq();
}
inline ::google::protobuf::uint32 IMUserSearchReq::search_seq() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchReq.search_seq)
  return search_seq_;
}
inline void IMUserSearchReq::set_search_seq(::google::protobuf::uint32 value) {
  set_has_search_seq();
  search_seq_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchReq.search_seq)
}

// required uint32 page_size = 5;
inline bool IMUserSearchReq::has_page_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUserSearchReq::set_has_page_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUserSearchReq::clear_has_page_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUserSearchReq::clear_page_size() {
  page_size_ = 0u;
  clear_has_page_size();
}
inline ::google::protobuf::uint32 IMUserSearchReq::page_size() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchReq.page_size)
  return page_size_;
}
inline void IMUserSearchReq::set_page_size(::google::protobuf::uint32 value) {
  set_has_page_size();
  page_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchReq.page_size)
}

// optional bytes attach_data = 20;
inline bool IMUserSearchReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMUserSearchReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMUserSearchReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMUserSearchReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserSearchReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchReq.attach_data)
  return *attach_data_;
}
inline void IMUserSearchReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchReq.attach_data)
}
inline void IMUserSearchReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserSearchReq.attach_data)
}
inline void IMUserSearchReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserSearchReq.attach_data)
}
inline ::std::string* IMUserSearchReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserSearchReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserSearchReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserSearchReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserSearchReq.attach_data)
}

// -------------------------------------------------------------------

// IMUserSearchRsp

// required uint32 user_id = 1;
inline bool IMUserSearchRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserSearchRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserSearchRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserSearchRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserSearchRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchRsp.user_id)
  return user_id_;
}
inline void IMUserSearchRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchRsp.user_id)
}

// required uint32 search_type = 2;
inline bool IMUserSearchRsp::has_search_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserSearchRsp::set_has_search_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserSearchRsp::clear_has_search_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserSearchRsp::clear_search_type() {
  search_type_ = 0u;
  clear_has_search_type();
}
inline ::google::protobuf::uint32 IMUserSearchRsp::search_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchRsp.search_type)
  return search_type_;
}
inline void IMUserSearchRsp::set_search_type(::google::protobuf::uint32 value) {
  set_has_search_type();
  search_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchRsp.search_type)
}

// required uint32 search_reault = 3;
inline bool IMUserSearchRsp::has_search_reault() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserSearchRsp::set_has_search_reault() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserSearchRsp::clear_has_search_reault() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserSearchRsp::clear_search_reault() {
  search_reault_ = 0u;
  clear_has_search_reault();
}
inline ::google::protobuf::uint32 IMUserSearchRsp::search_reault() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchRsp.search_reault)
  return search_reault_;
}
inline void IMUserSearchRsp::set_search_reault(::google::protobuf::uint32 value) {
  set_has_search_reault();
  search_reault_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchRsp.search_reault)
}

// required uint32 search_seq = 4;
inline bool IMUserSearchRsp::has_search_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserSearchRsp::set_has_search_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserSearchRsp::clear_has_search_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserSearchRsp::clear_search_seq() {
  search_seq_ = 0u;
  clear_has_search_seq();
}
inline ::google::protobuf::uint32 IMUserSearchRsp::search_seq() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchRsp.search_seq)
  return search_seq_;
}
inline void IMUserSearchRsp::set_search_seq(::google::protobuf::uint32 value) {
  set_has_search_seq();
  search_seq_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchRsp.search_seq)
}

// repeated .IM.BaseDefine.UserInfo user_info_list = 5;
inline int IMUserSearchRsp::user_info_list_size() const {
  return user_info_list_.size();
}
inline void IMUserSearchRsp::clear_user_info_list() {
  user_info_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMUserSearchRsp::user_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchRsp.user_info_list)
  return user_info_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMUserSearchRsp::mutable_user_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserSearchRsp.user_info_list)
  return user_info_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMUserSearchRsp::add_user_info_list() {
  // @@protoc_insertion_point(field_add:IM.Buddy.IMUserSearchRsp.user_info_list)
  return user_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMUserSearchRsp::user_info_list() const {
  // @@protoc_insertion_point(field_list:IM.Buddy.IMUserSearchRsp.user_info_list)
  return user_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMUserSearchRsp::mutable_user_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Buddy.IMUserSearchRsp.user_info_list)
  return &user_info_list_;
}

// optional bytes attach_data = 20;
inline bool IMUserSearchRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMUserSearchRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMUserSearchRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMUserSearchRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserSearchRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserSearchRsp.attach_data)
  return *attach_data_;
}
inline void IMUserSearchRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserSearchRsp.attach_data)
}
inline void IMUserSearchRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserSearchRsp.attach_data)
}
inline void IMUserSearchRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserSearchRsp.attach_data)
}
inline ::std::string* IMUserSearchRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserSearchRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserSearchRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserSearchRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserSearchRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserAddFriendReq

// required uint32 user_id = 1;
inline bool IMUserAddFriendReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserAddFriendReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserAddFriendReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserAddFriendReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendReq.user_id)
  return user_id_;
}
inline void IMUserAddFriendReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendReq.user_id)
}

// required uint32 add_id = 2;
inline bool IMUserAddFriendReq::has_add_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserAddFriendReq::set_has_add_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserAddFriendReq::clear_has_add_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserAddFriendReq::clear_add_id() {
  add_id_ = 0u;
  clear_has_add_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendReq::add_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendReq.add_id)
  return add_id_;
}
inline void IMUserAddFriendReq::set_add_id(::google::protobuf::uint32 value) {
  set_has_add_id();
  add_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendReq.add_id)
}

// optional string str_valid = 3;
inline bool IMUserAddFriendReq::has_str_valid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserAddFriendReq::set_has_str_valid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserAddFriendReq::clear_has_str_valid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserAddFriendReq::clear_str_valid() {
  if (str_valid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_valid_->clear();
  }
  clear_has_str_valid();
}
inline const ::std::string& IMUserAddFriendReq::str_valid() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendReq.str_valid)
  return *str_valid_;
}
inline void IMUserAddFriendReq::set_str_valid(const ::std::string& value) {
  set_has_str_valid();
  if (str_valid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_valid_ = new ::std::string;
  }
  str_valid_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendReq.str_valid)
}
inline void IMUserAddFriendReq::set_str_valid(const char* value) {
  set_has_str_valid();
  if (str_valid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_valid_ = new ::std::string;
  }
  str_valid_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendReq.str_valid)
}
inline void IMUserAddFriendReq::set_str_valid(const char* value, size_t size) {
  set_has_str_valid();
  if (str_valid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_valid_ = new ::std::string;
  }
  str_valid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendReq.str_valid)
}
inline ::std::string* IMUserAddFriendReq::mutable_str_valid() {
  set_has_str_valid();
  if (str_valid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_valid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendReq.str_valid)
  return str_valid_;
}
inline ::std::string* IMUserAddFriendReq::release_str_valid() {
  clear_has_str_valid();
  if (str_valid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = str_valid_;
    str_valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendReq::set_allocated_str_valid(::std::string* str_valid) {
  if (str_valid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete str_valid_;
  }
  if (str_valid) {
    set_has_str_valid();
    str_valid_ = str_valid;
  } else {
    clear_has_str_valid();
    str_valid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendReq.str_valid)
}

// optional bytes attach_data = 20;
inline bool IMUserAddFriendReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserAddFriendReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserAddFriendReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserAddFriendReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserAddFriendReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendReq.attach_data)
  return *attach_data_;
}
inline void IMUserAddFriendReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendReq.attach_data)
}
inline void IMUserAddFriendReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendReq.attach_data)
}
inline void IMUserAddFriendReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendReq.attach_data)
}
inline ::std::string* IMUserAddFriendReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserAddFriendReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendReq.attach_data)
}

// -------------------------------------------------------------------

// IMUserAddFriendRsp

// required uint32 user_id = 1;
inline bool IMUserAddFriendRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserAddFriendRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserAddFriendRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserAddFriendRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendRsp.user_id)
  return user_id_;
}
inline void IMUserAddFriendRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendRsp.user_id)
}

// required uint32 add_id = 2;
inline bool IMUserAddFriendRsp::has_add_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserAddFriendRsp::set_has_add_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserAddFriendRsp::clear_has_add_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserAddFriendRsp::clear_add_id() {
  add_id_ = 0u;
  clear_has_add_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendRsp::add_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendRsp.add_id)
  return add_id_;
}
inline void IMUserAddFriendRsp::set_add_id(::google::protobuf::uint32 value) {
  set_has_add_id();
  add_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendRsp.add_id)
}

// required uint32 result_code = 3;
inline bool IMUserAddFriendRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserAddFriendRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserAddFriendRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserAddFriendRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMUserAddFriendRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendRsp.result_code)
  return result_code_;
}
inline void IMUserAddFriendRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendRsp.result_code)
}

// required string result_des = 4;
inline bool IMUserAddFriendRsp::has_result_des() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserAddFriendRsp::set_has_result_des() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserAddFriendRsp::clear_has_result_des() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserAddFriendRsp::clear_result_des() {
  if (result_des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_->clear();
  }
  clear_has_result_des();
}
inline const ::std::string& IMUserAddFriendRsp::result_des() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendRsp.result_des)
  return *result_des_;
}
inline void IMUserAddFriendRsp::set_result_des(const ::std::string& value) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendRsp.result_des)
}
inline void IMUserAddFriendRsp::set_result_des(const char* value) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendRsp.result_des)
}
inline void IMUserAddFriendRsp::set_result_des(const char* value, size_t size) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendRsp.result_des)
}
inline ::std::string* IMUserAddFriendRsp::mutable_result_des() {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendRsp.result_des)
  return result_des_;
}
inline ::std::string* IMUserAddFriendRsp::release_result_des() {
  clear_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_des_;
    result_des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendRsp::set_allocated_result_des(::std::string* result_des) {
  if (result_des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_des_;
  }
  if (result_des) {
    set_has_result_des();
    result_des_ = result_des;
  } else {
    clear_has_result_des();
    result_des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendRsp.result_des)
}

// optional bytes attach_data = 20;
inline bool IMUserAddFriendRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUserAddFriendRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUserAddFriendRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUserAddFriendRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserAddFriendRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendRsp.attach_data)
  return *attach_data_;
}
inline void IMUserAddFriendRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendRsp.attach_data)
}
inline void IMUserAddFriendRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendRsp.attach_data)
}
inline void IMUserAddFriendRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendRsp.attach_data)
}
inline ::std::string* IMUserAddFriendRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserAddFriendRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserRemFriendReq

// required uint32 user_id = 1;
inline bool IMUserRemFriendReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserRemFriendReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserRemFriendReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserRemFriendReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserRemFriendReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserRemFriendReq.user_id)
  return user_id_;
}
inline void IMUserRemFriendReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserRemFriendReq.user_id)
}

// required uint32 remove_id = 2;
inline bool IMUserRemFriendReq::has_remove_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserRemFriendReq::set_has_remove_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserRemFriendReq::clear_has_remove_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserRemFriendReq::clear_remove_id() {
  remove_id_ = 0u;
  clear_has_remove_id();
}
inline ::google::protobuf::uint32 IMUserRemFriendReq::remove_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserRemFriendReq.remove_id)
  return remove_id_;
}
inline void IMUserRemFriendReq::set_remove_id(::google::protobuf::uint32 value) {
  set_has_remove_id();
  remove_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserRemFriendReq.remove_id)
}

// optional bytes attach_data = 20;
inline bool IMUserRemFriendReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserRemFriendReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserRemFriendReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserRemFriendReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserRemFriendReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserRemFriendReq.attach_data)
  return *attach_data_;
}
inline void IMUserRemFriendReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserRemFriendReq.attach_data)
}
inline void IMUserRemFriendReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserRemFriendReq.attach_data)
}
inline void IMUserRemFriendReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserRemFriendReq.attach_data)
}
inline ::std::string* IMUserRemFriendReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserRemFriendReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserRemFriendReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserRemFriendReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserRemFriendReq.attach_data)
}

// -------------------------------------------------------------------

// IMUserRemFriendRsp

// required uint32 user_id = 1;
inline bool IMUserRemFriendRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserRemFriendRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserRemFriendRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserRemFriendRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserRemFriendRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserRemFriendRsp.user_id)
  return user_id_;
}
inline void IMUserRemFriendRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserRemFriendRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMUserRemFriendRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserRemFriendRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserRemFriendRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserRemFriendRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMUserRemFriendRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserRemFriendRsp.result_code)
  return result_code_;
}
inline void IMUserRemFriendRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserRemFriendRsp.result_code)
}

// required uint32 rm_id = 3;
inline bool IMUserRemFriendRsp::has_rm_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserRemFriendRsp::set_has_rm_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserRemFriendRsp::clear_has_rm_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserRemFriendRsp::clear_rm_id() {
  rm_id_ = 0u;
  clear_has_rm_id();
}
inline ::google::protobuf::uint32 IMUserRemFriendRsp::rm_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserRemFriendRsp.rm_id)
  return rm_id_;
}
inline void IMUserRemFriendRsp::set_rm_id(::google::protobuf::uint32 value) {
  set_has_rm_id();
  rm_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserRemFriendRsp.rm_id)
}

// required string result_string = 4;
inline bool IMUserRemFriendRsp::has_result_string() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserRemFriendRsp::set_has_result_string() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserRemFriendRsp::clear_has_result_string() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserRemFriendRsp::clear_result_string() {
  if (result_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_->clear();
  }
  clear_has_result_string();
}
inline const ::std::string& IMUserRemFriendRsp::result_string() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserRemFriendRsp.result_string)
  return *result_string_;
}
inline void IMUserRemFriendRsp::set_result_string(const ::std::string& value) {
  set_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_ = new ::std::string;
  }
  result_string_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserRemFriendRsp.result_string)
}
inline void IMUserRemFriendRsp::set_result_string(const char* value) {
  set_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_ = new ::std::string;
  }
  result_string_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserRemFriendRsp.result_string)
}
inline void IMUserRemFriendRsp::set_result_string(const char* value, size_t size) {
  set_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_ = new ::std::string;
  }
  result_string_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserRemFriendRsp.result_string)
}
inline ::std::string* IMUserRemFriendRsp::mutable_result_string() {
  set_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserRemFriendRsp.result_string)
  return result_string_;
}
inline ::std::string* IMUserRemFriendRsp::release_result_string() {
  clear_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_string_;
    result_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserRemFriendRsp::set_allocated_result_string(::std::string* result_string) {
  if (result_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_string_;
  }
  if (result_string) {
    set_has_result_string();
    result_string_ = result_string;
  } else {
    clear_has_result_string();
    result_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserRemFriendRsp.result_string)
}

// optional bytes attach_data = 20;
inline bool IMUserRemFriendRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUserRemFriendRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUserRemFriendRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUserRemFriendRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserRemFriendRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserRemFriendRsp.attach_data)
  return *attach_data_;
}
inline void IMUserRemFriendRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserRemFriendRsp.attach_data)
}
inline void IMUserRemFriendRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserRemFriendRsp.attach_data)
}
inline void IMUserRemFriendRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserRemFriendRsp.attach_data)
}
inline ::std::string* IMUserRemFriendRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserRemFriendRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserRemFriendRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserRemFriendRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserRemFriendRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserInfoChangeReq

// required uint32 user_id = 1;
inline bool IMUserInfoChangeReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserInfoChangeReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserInfoChangeReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserInfoChangeReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserInfoChangeReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserInfoChangeReq.user_id)
  return user_id_;
}
inline void IMUserInfoChangeReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserInfoChangeReq.user_id)
}

// required uint32 change_type = 2;
inline bool IMUserInfoChangeReq::has_change_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserInfoChangeReq::set_has_change_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserInfoChangeReq::clear_has_change_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserInfoChangeReq::clear_change_type() {
  change_type_ = 0u;
  clear_has_change_type();
}
inline ::google::protobuf::uint32 IMUserInfoChangeReq::change_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserInfoChangeReq.change_type)
  return change_type_;
}
inline void IMUserInfoChangeReq::set_change_type(::google::protobuf::uint32 value) {
  set_has_change_type();
  change_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserInfoChangeReq.change_type)
}

// required string change_content = 3;
inline bool IMUserInfoChangeReq::has_change_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserInfoChangeReq::set_has_change_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserInfoChangeReq::clear_has_change_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserInfoChangeReq::clear_change_content() {
  if (change_content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    change_content_->clear();
  }
  clear_has_change_content();
}
inline const ::std::string& IMUserInfoChangeReq::change_content() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserInfoChangeReq.change_content)
  return *change_content_;
}
inline void IMUserInfoChangeReq::set_change_content(const ::std::string& value) {
  set_has_change_content();
  if (change_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    change_content_ = new ::std::string;
  }
  change_content_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserInfoChangeReq.change_content)
}
inline void IMUserInfoChangeReq::set_change_content(const char* value) {
  set_has_change_content();
  if (change_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    change_content_ = new ::std::string;
  }
  change_content_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserInfoChangeReq.change_content)
}
inline void IMUserInfoChangeReq::set_change_content(const char* value, size_t size) {
  set_has_change_content();
  if (change_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    change_content_ = new ::std::string;
  }
  change_content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserInfoChangeReq.change_content)
}
inline ::std::string* IMUserInfoChangeReq::mutable_change_content() {
  set_has_change_content();
  if (change_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    change_content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserInfoChangeReq.change_content)
  return change_content_;
}
inline ::std::string* IMUserInfoChangeReq::release_change_content() {
  clear_has_change_content();
  if (change_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = change_content_;
    change_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserInfoChangeReq::set_allocated_change_content(::std::string* change_content) {
  if (change_content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete change_content_;
  }
  if (change_content) {
    set_has_change_content();
    change_content_ = change_content;
  } else {
    clear_has_change_content();
    change_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserInfoChangeReq.change_content)
}

// optional bytes attach_data = 20;
inline bool IMUserInfoChangeReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserInfoChangeReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserInfoChangeReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserInfoChangeReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserInfoChangeReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserInfoChangeReq.attach_data)
  return *attach_data_;
}
inline void IMUserInfoChangeReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserInfoChangeReq.attach_data)
}
inline void IMUserInfoChangeReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserInfoChangeReq.attach_data)
}
inline void IMUserInfoChangeReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserInfoChangeReq.attach_data)
}
inline ::std::string* IMUserInfoChangeReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserInfoChangeReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserInfoChangeReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserInfoChangeReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserInfoChangeReq.attach_data)
}

// -------------------------------------------------------------------

// IMUserInfoChangeRsp

// required uint32 user_id = 1;
inline bool IMUserInfoChangeRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserInfoChangeRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserInfoChangeRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserInfoChangeRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserInfoChangeRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserInfoChangeRsp.user_id)
  return user_id_;
}
inline void IMUserInfoChangeRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserInfoChangeRsp.user_id)
}

// required uint32 result_code = 2;
inline bool IMUserInfoChangeRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserInfoChangeRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserInfoChangeRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserInfoChangeRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMUserInfoChangeRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserInfoChangeRsp.result_code)
  return result_code_;
}
inline void IMUserInfoChangeRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserInfoChangeRsp.result_code)
}

// required string result_des = 3;
inline bool IMUserInfoChangeRsp::has_result_des() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserInfoChangeRsp::set_has_result_des() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserInfoChangeRsp::clear_has_result_des() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserInfoChangeRsp::clear_result_des() {
  if (result_des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_->clear();
  }
  clear_has_result_des();
}
inline const ::std::string& IMUserInfoChangeRsp::result_des() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserInfoChangeRsp.result_des)
  return *result_des_;
}
inline void IMUserInfoChangeRsp::set_result_des(const ::std::string& value) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserInfoChangeRsp.result_des)
}
inline void IMUserInfoChangeRsp::set_result_des(const char* value) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserInfoChangeRsp.result_des)
}
inline void IMUserInfoChangeRsp::set_result_des(const char* value, size_t size) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserInfoChangeRsp.result_des)
}
inline ::std::string* IMUserInfoChangeRsp::mutable_result_des() {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserInfoChangeRsp.result_des)
  return result_des_;
}
inline ::std::string* IMUserInfoChangeRsp::release_result_des() {
  clear_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_des_;
    result_des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserInfoChangeRsp::set_allocated_result_des(::std::string* result_des) {
  if (result_des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_des_;
  }
  if (result_des) {
    set_has_result_des();
    result_des_ = result_des;
  } else {
    clear_has_result_des();
    result_des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserInfoChangeRsp.result_des)
}

// required uint32 change_type = 4;
inline bool IMUserInfoChangeRsp::has_change_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserInfoChangeRsp::set_has_change_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserInfoChangeRsp::clear_has_change_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserInfoChangeRsp::clear_change_type() {
  change_type_ = 0u;
  clear_has_change_type();
}
inline ::google::protobuf::uint32 IMUserInfoChangeRsp::change_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserInfoChangeRsp.change_type)
  return change_type_;
}
inline void IMUserInfoChangeRsp::set_change_type(::google::protobuf::uint32 value) {
  set_has_change_type();
  change_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserInfoChangeRsp.change_type)
}

// optional bytes attach_data = 20;
inline bool IMUserInfoChangeRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUserInfoChangeRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUserInfoChangeRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUserInfoChangeRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserInfoChangeRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserInfoChangeRsp.attach_data)
  return *attach_data_;
}
inline void IMUserInfoChangeRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserInfoChangeRsp.attach_data)
}
inline void IMUserInfoChangeRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserInfoChangeRsp.attach_data)
}
inline void IMUserInfoChangeRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserInfoChangeRsp.attach_data)
}
inline ::std::string* IMUserInfoChangeRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserInfoChangeRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserInfoChangeRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserInfoChangeRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserInfoChangeRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserAddFriendToUserRsp

// required uint32 user_id = 1;
inline bool IMUserAddFriendToUserRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserAddFriendToUserRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserAddFriendToUserRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserAddFriendToUserRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendToUserRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToUserRsp.user_id)
  return user_id_;
}
inline void IMUserAddFriendToUserRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToUserRsp.user_id)
}

// required uint32 from_id = 2;
inline bool IMUserAddFriendToUserRsp::has_from_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserAddFriendToUserRsp::set_has_from_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserAddFriendToUserRsp::clear_has_from_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserAddFriendToUserRsp::clear_from_id() {
  from_id_ = 0u;
  clear_has_from_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendToUserRsp::from_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToUserRsp.from_id)
  return from_id_;
}
inline void IMUserAddFriendToUserRsp::set_from_id(::google::protobuf::uint32 value) {
  set_has_from_id();
  from_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToUserRsp.from_id)
}

// required uint32 msg_id = 3;
inline bool IMUserAddFriendToUserRsp::has_msg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserAddFriendToUserRsp::set_has_msg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserAddFriendToUserRsp::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserAddFriendToUserRsp::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendToUserRsp::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToUserRsp.msg_id)
  return msg_id_;
}
inline void IMUserAddFriendToUserRsp::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToUserRsp.msg_id)
}

// required .IM.BaseDefine.UserInfo user_info = 4;
inline bool IMUserAddFriendToUserRsp::has_user_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserAddFriendToUserRsp::set_has_user_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserAddFriendToUserRsp::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserAddFriendToUserRsp::clear_user_info() {
  if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
  clear_has_user_info();
}
inline const ::IM::BaseDefine::UserInfo& IMUserAddFriendToUserRsp::user_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToUserRsp.user_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_info_ != NULL ? *user_info_ : *default_instance().user_info_;
#else
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
#endif
}
inline ::IM::BaseDefine::UserInfo* IMUserAddFriendToUserRsp::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::IM::BaseDefine::UserInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendToUserRsp.user_info)
  return user_info_;
}
inline ::IM::BaseDefine::UserInfo* IMUserAddFriendToUserRsp::release_user_info() {
  clear_has_user_info();
  ::IM::BaseDefine::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void IMUserAddFriendToUserRsp::set_allocated_user_info(::IM::BaseDefine::UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendToUserRsp.user_info)
}

// required .IM.BaseDefine.SessionType msg_type = 5;
inline bool IMUserAddFriendToUserRsp::has_msg_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUserAddFriendToUserRsp::set_has_msg_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUserAddFriendToUserRsp::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUserAddFriendToUserRsp::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::IM::BaseDefine::SessionType IMUserAddFriendToUserRsp::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToUserRsp.msg_type)
  return static_cast< ::IM::BaseDefine::SessionType >(msg_type_);
}
inline void IMUserAddFriendToUserRsp::set_msg_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToUserRsp.msg_type)
}

// required .IM.BaseDefine.AddFriendStatus status = 6;
inline bool IMUserAddFriendToUserRsp::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMUserAddFriendToUserRsp::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMUserAddFriendToUserRsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMUserAddFriendToUserRsp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::IM::BaseDefine::AddFriendStatus IMUserAddFriendToUserRsp::status() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToUserRsp.status)
  return static_cast< ::IM::BaseDefine::AddFriendStatus >(status_);
}
inline void IMUserAddFriendToUserRsp::set_status(::IM::BaseDefine::AddFriendStatus value) {
  assert(::IM::BaseDefine::AddFriendStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToUserRsp.status)
}

// required uint32 create_time = 7;
inline bool IMUserAddFriendToUserRsp::has_create_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMUserAddFriendToUserRsp::set_has_create_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMUserAddFriendToUserRsp::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMUserAddFriendToUserRsp::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 IMUserAddFriendToUserRsp::create_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToUserRsp.create_time)
  return create_time_;
}
inline void IMUserAddFriendToUserRsp::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToUserRsp.create_time)
}

// optional string content = 8;
inline bool IMUserAddFriendToUserRsp::has_content() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMUserAddFriendToUserRsp::set_has_content() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMUserAddFriendToUserRsp::clear_has_content() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMUserAddFriendToUserRsp::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& IMUserAddFriendToUserRsp::content() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToUserRsp.content)
  return *content_;
}
inline void IMUserAddFriendToUserRsp::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToUserRsp.content)
}
inline void IMUserAddFriendToUserRsp::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendToUserRsp.content)
}
inline void IMUserAddFriendToUserRsp::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendToUserRsp.content)
}
inline ::std::string* IMUserAddFriendToUserRsp::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendToUserRsp.content)
  return content_;
}
inline ::std::string* IMUserAddFriendToUserRsp::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendToUserRsp::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendToUserRsp.content)
}

// optional bytes attach_data = 20;
inline bool IMUserAddFriendToUserRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IMUserAddFriendToUserRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IMUserAddFriendToUserRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IMUserAddFriendToUserRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserAddFriendToUserRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToUserRsp.attach_data)
  return *attach_data_;
}
inline void IMUserAddFriendToUserRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToUserRsp.attach_data)
}
inline void IMUserAddFriendToUserRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendToUserRsp.attach_data)
}
inline void IMUserAddFriendToUserRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendToUserRsp.attach_data)
}
inline ::std::string* IMUserAddFriendToUserRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendToUserRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserAddFriendToUserRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendToUserRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendToUserRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserAddFriendTargetReq

// required uint32 user_id = 1;
inline bool IMUserAddFriendTargetReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserAddFriendTargetReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserAddFriendTargetReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserAddFriendTargetReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendTargetReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetReq.user_id)
  return user_id_;
}
inline void IMUserAddFriendTargetReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetReq.user_id)
}

// required uint32 from_id = 2;
inline bool IMUserAddFriendTargetReq::has_from_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserAddFriendTargetReq::set_has_from_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserAddFriendTargetReq::clear_has_from_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserAddFriendTargetReq::clear_from_id() {
  from_id_ = 0u;
  clear_has_from_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendTargetReq::from_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetReq.from_id)
  return from_id_;
}
inline void IMUserAddFriendTargetReq::set_from_id(::google::protobuf::uint32 value) {
  set_has_from_id();
  from_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetReq.from_id)
}

// required uint32 msg_id = 3;
inline bool IMUserAddFriendTargetReq::has_msg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserAddFriendTargetReq::set_has_msg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserAddFriendTargetReq::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserAddFriendTargetReq::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendTargetReq::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetReq.msg_id)
  return msg_id_;
}
inline void IMUserAddFriendTargetReq::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetReq.msg_id)
}

// required .IM.BaseDefine.AddFriendStatus status = 4;
inline bool IMUserAddFriendTargetReq::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserAddFriendTargetReq::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserAddFriendTargetReq::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserAddFriendTargetReq::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::IM::BaseDefine::AddFriendStatus IMUserAddFriendTargetReq::status() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetReq.status)
  return static_cast< ::IM::BaseDefine::AddFriendStatus >(status_);
}
inline void IMUserAddFriendTargetReq::set_status(::IM::BaseDefine::AddFriendStatus value) {
  assert(::IM::BaseDefine::AddFriendStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetReq.status)
}

// optional bytes attach_data = 20;
inline bool IMUserAddFriendTargetReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUserAddFriendTargetReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUserAddFriendTargetReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUserAddFriendTargetReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserAddFriendTargetReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetReq.attach_data)
  return *attach_data_;
}
inline void IMUserAddFriendTargetReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetReq.attach_data)
}
inline void IMUserAddFriendTargetReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendTargetReq.attach_data)
}
inline void IMUserAddFriendTargetReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendTargetReq.attach_data)
}
inline ::std::string* IMUserAddFriendTargetReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendTargetReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserAddFriendTargetReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendTargetReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendTargetReq.attach_data)
}

// -------------------------------------------------------------------

// IMUserAddFriendTargetRsp

// required uint32 user_id = 1;
inline bool IMUserAddFriendTargetRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserAddFriendTargetRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserAddFriendTargetRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserAddFriendTargetRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendTargetRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetRsp.user_id)
  return user_id_;
}
inline void IMUserAddFriendTargetRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetRsp.user_id)
}

// required uint32 from_id = 2;
inline bool IMUserAddFriendTargetRsp::has_from_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserAddFriendTargetRsp::set_has_from_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserAddFriendTargetRsp::clear_has_from_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserAddFriendTargetRsp::clear_from_id() {
  from_id_ = 0u;
  clear_has_from_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendTargetRsp::from_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetRsp.from_id)
  return from_id_;
}
inline void IMUserAddFriendTargetRsp::set_from_id(::google::protobuf::uint32 value) {
  set_has_from_id();
  from_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetRsp.from_id)
}

// required uint32 msg_id = 3;
inline bool IMUserAddFriendTargetRsp::has_msg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserAddFriendTargetRsp::set_has_msg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserAddFriendTargetRsp::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserAddFriendTargetRsp::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendTargetRsp::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetRsp.msg_id)
  return msg_id_;
}
inline void IMUserAddFriendTargetRsp::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetRsp.msg_id)
}

// required .IM.BaseDefine.AddFriendStatus status = 4;
inline bool IMUserAddFriendTargetRsp::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserAddFriendTargetRsp::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserAddFriendTargetRsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserAddFriendTargetRsp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::IM::BaseDefine::AddFriendStatus IMUserAddFriendTargetRsp::status() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetRsp.status)
  return static_cast< ::IM::BaseDefine::AddFriendStatus >(status_);
}
inline void IMUserAddFriendTargetRsp::set_status(::IM::BaseDefine::AddFriendStatus value) {
  assert(::IM::BaseDefine::AddFriendStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetRsp.status)
}

// required uint32 result_code = 5;
inline bool IMUserAddFriendTargetRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUserAddFriendTargetRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUserAddFriendTargetRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUserAddFriendTargetRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMUserAddFriendTargetRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetRsp.result_code)
  return result_code_;
}
inline void IMUserAddFriendTargetRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetRsp.result_code)
}

// required string result_des = 6;
inline bool IMUserAddFriendTargetRsp::has_result_des() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMUserAddFriendTargetRsp::set_has_result_des() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMUserAddFriendTargetRsp::clear_has_result_des() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMUserAddFriendTargetRsp::clear_result_des() {
  if (result_des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_->clear();
  }
  clear_has_result_des();
}
inline const ::std::string& IMUserAddFriendTargetRsp::result_des() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetRsp.result_des)
  return *result_des_;
}
inline void IMUserAddFriendTargetRsp::set_result_des(const ::std::string& value) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetRsp.result_des)
}
inline void IMUserAddFriendTargetRsp::set_result_des(const char* value) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendTargetRsp.result_des)
}
inline void IMUserAddFriendTargetRsp::set_result_des(const char* value, size_t size) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendTargetRsp.result_des)
}
inline ::std::string* IMUserAddFriendTargetRsp::mutable_result_des() {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendTargetRsp.result_des)
  return result_des_;
}
inline ::std::string* IMUserAddFriendTargetRsp::release_result_des() {
  clear_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_des_;
    result_des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendTargetRsp::set_allocated_result_des(::std::string* result_des) {
  if (result_des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_des_;
  }
  if (result_des) {
    set_has_result_des();
    result_des_ = result_des;
  } else {
    clear_has_result_des();
    result_des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendTargetRsp.result_des)
}

// required .IM.BaseDefine.UserInfo user_info = 7;
inline bool IMUserAddFriendTargetRsp::has_user_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMUserAddFriendTargetRsp::set_has_user_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMUserAddFriendTargetRsp::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMUserAddFriendTargetRsp::clear_user_info() {
  if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
  clear_has_user_info();
}
inline const ::IM::BaseDefine::UserInfo& IMUserAddFriendTargetRsp::user_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetRsp.user_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_info_ != NULL ? *user_info_ : *default_instance().user_info_;
#else
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
#endif
}
inline ::IM::BaseDefine::UserInfo* IMUserAddFriendTargetRsp::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::IM::BaseDefine::UserInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendTargetRsp.user_info)
  return user_info_;
}
inline ::IM::BaseDefine::UserInfo* IMUserAddFriendTargetRsp::release_user_info() {
  clear_has_user_info();
  ::IM::BaseDefine::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void IMUserAddFriendTargetRsp::set_allocated_user_info(::IM::BaseDefine::UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendTargetRsp.user_info)
}

// optional bytes attach_data = 20;
inline bool IMUserAddFriendTargetRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMUserAddFriendTargetRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMUserAddFriendTargetRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMUserAddFriendTargetRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserAddFriendTargetRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendTargetRsp.attach_data)
  return *attach_data_;
}
inline void IMUserAddFriendTargetRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendTargetRsp.attach_data)
}
inline void IMUserAddFriendTargetRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendTargetRsp.attach_data)
}
inline void IMUserAddFriendTargetRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendTargetRsp.attach_data)
}
inline ::std::string* IMUserAddFriendTargetRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendTargetRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserAddFriendTargetRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendTargetRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendTargetRsp.attach_data)
}

// -------------------------------------------------------------------

// IMUserAddFriendToSelfRsp

// required uint32 user_id = 1;
inline bool IMUserAddFriendToSelfRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserAddFriendToSelfRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendToSelfRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.user_id)
  return user_id_;
}
inline void IMUserAddFriendToSelfRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToSelfRsp.user_id)
}

// required uint32 from_id = 2;
inline bool IMUserAddFriendToSelfRsp::has_from_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_from_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_from_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserAddFriendToSelfRsp::clear_from_id() {
  from_id_ = 0u;
  clear_has_from_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendToSelfRsp::from_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.from_id)
  return from_id_;
}
inline void IMUserAddFriendToSelfRsp::set_from_id(::google::protobuf::uint32 value) {
  set_has_from_id();
  from_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToSelfRsp.from_id)
}

// required uint32 msg_id = 3;
inline bool IMUserAddFriendToSelfRsp::has_msg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_msg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserAddFriendToSelfRsp::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 IMUserAddFriendToSelfRsp::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.msg_id)
  return msg_id_;
}
inline void IMUserAddFriendToSelfRsp::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToSelfRsp.msg_id)
}

// required .IM.BaseDefine.UserInfo user_info = 4;
inline bool IMUserAddFriendToSelfRsp::has_user_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_user_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserAddFriendToSelfRsp::clear_user_info() {
  if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
  clear_has_user_info();
}
inline const ::IM::BaseDefine::UserInfo& IMUserAddFriendToSelfRsp::user_info() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.user_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_info_ != NULL ? *user_info_ : *default_instance().user_info_;
#else
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
#endif
}
inline ::IM::BaseDefine::UserInfo* IMUserAddFriendToSelfRsp::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::IM::BaseDefine::UserInfo;
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendToSelfRsp.user_info)
  return user_info_;
}
inline ::IM::BaseDefine::UserInfo* IMUserAddFriendToSelfRsp::release_user_info() {
  clear_has_user_info();
  ::IM::BaseDefine::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void IMUserAddFriendToSelfRsp::set_allocated_user_info(::IM::BaseDefine::UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendToSelfRsp.user_info)
}

// required .IM.BaseDefine.SessionType msg_type = 5;
inline bool IMUserAddFriendToSelfRsp::has_msg_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_msg_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUserAddFriendToSelfRsp::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::IM::BaseDefine::SessionType IMUserAddFriendToSelfRsp::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.msg_type)
  return static_cast< ::IM::BaseDefine::SessionType >(msg_type_);
}
inline void IMUserAddFriendToSelfRsp::set_msg_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToSelfRsp.msg_type)
}

// required uint32 create_time = 6;
inline bool IMUserAddFriendToSelfRsp::has_create_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_create_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMUserAddFriendToSelfRsp::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 IMUserAddFriendToSelfRsp::create_time() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.create_time)
  return create_time_;
}
inline void IMUserAddFriendToSelfRsp::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToSelfRsp.create_time)
}

// required .IM.BaseDefine.AddFriendStatus status = 7;
inline bool IMUserAddFriendToSelfRsp::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMUserAddFriendToSelfRsp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::IM::BaseDefine::AddFriendStatus IMUserAddFriendToSelfRsp::status() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.status)
  return static_cast< ::IM::BaseDefine::AddFriendStatus >(status_);
}
inline void IMUserAddFriendToSelfRsp::set_status(::IM::BaseDefine::AddFriendStatus value) {
  assert(::IM::BaseDefine::AddFriendStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToSelfRsp.status)
}

// required string result_des = 8;
inline bool IMUserAddFriendToSelfRsp::has_result_des() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_result_des() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_result_des() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMUserAddFriendToSelfRsp::clear_result_des() {
  if (result_des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_->clear();
  }
  clear_has_result_des();
}
inline const ::std::string& IMUserAddFriendToSelfRsp::result_des() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.result_des)
  return *result_des_;
}
inline void IMUserAddFriendToSelfRsp::set_result_des(const ::std::string& value) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToSelfRsp.result_des)
}
inline void IMUserAddFriendToSelfRsp::set_result_des(const char* value) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendToSelfRsp.result_des)
}
inline void IMUserAddFriendToSelfRsp::set_result_des(const char* value, size_t size) {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  result_des_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendToSelfRsp.result_des)
}
inline ::std::string* IMUserAddFriendToSelfRsp::mutable_result_des() {
  set_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_des_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendToSelfRsp.result_des)
  return result_des_;
}
inline ::std::string* IMUserAddFriendToSelfRsp::release_result_des() {
  clear_has_result_des();
  if (result_des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_des_;
    result_des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendToSelfRsp::set_allocated_result_des(::std::string* result_des) {
  if (result_des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_des_;
  }
  if (result_des) {
    set_has_result_des();
    result_des_ = result_des;
  } else {
    clear_has_result_des();
    result_des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendToSelfRsp.result_des)
}

// optional string content = 9;
inline bool IMUserAddFriendToSelfRsp::has_content() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_content() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_content() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IMUserAddFriendToSelfRsp::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& IMUserAddFriendToSelfRsp::content() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.content)
  return *content_;
}
inline void IMUserAddFriendToSelfRsp::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToSelfRsp.content)
}
inline void IMUserAddFriendToSelfRsp::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendToSelfRsp.content)
}
inline void IMUserAddFriendToSelfRsp::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendToSelfRsp.content)
}
inline ::std::string* IMUserAddFriendToSelfRsp::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendToSelfRsp.content)
  return content_;
}
inline ::std::string* IMUserAddFriendToSelfRsp::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendToSelfRsp::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendToSelfRsp.content)
}

// optional bytes attach_data = 20;
inline bool IMUserAddFriendToSelfRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IMUserAddFriendToSelfRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IMUserAddFriendToSelfRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IMUserAddFriendToSelfRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUserAddFriendToSelfRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMUserAddFriendToSelfRsp.attach_data)
  return *attach_data_;
}
inline void IMUserAddFriendToSelfRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMUserAddFriendToSelfRsp.attach_data)
}
inline void IMUserAddFriendToSelfRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMUserAddFriendToSelfRsp.attach_data)
}
inline void IMUserAddFriendToSelfRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMUserAddFriendToSelfRsp.attach_data)
}
inline ::std::string* IMUserAddFriendToSelfRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMUserAddFriendToSelfRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMUserAddFriendToSelfRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAddFriendToSelfRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMUserAddFriendToSelfRsp.attach_data)
}

// -------------------------------------------------------------------

// IMSendDelMsgToTargetRsp

// required uint32 user_id = 1;
inline bool IMSendDelMsgToTargetRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSendDelMsgToTargetRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSendDelMsgToTargetRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSendDelMsgToTargetRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMSendDelMsgToTargetRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSendDelMsgToTargetRsp.user_id)
  return user_id_;
}
inline void IMSendDelMsgToTargetRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSendDelMsgToTargetRsp.user_id)
}

// required uint32 from_id = 2;
inline bool IMSendDelMsgToTargetRsp::has_from_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSendDelMsgToTargetRsp::set_has_from_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSendDelMsgToTargetRsp::clear_has_from_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSendDelMsgToTargetRsp::clear_from_id() {
  from_id_ = 0u;
  clear_has_from_id();
}
inline ::google::protobuf::uint32 IMSendDelMsgToTargetRsp::from_id() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSendDelMsgToTargetRsp.from_id)
  return from_id_;
}
inline void IMSendDelMsgToTargetRsp::set_from_id(::google::protobuf::uint32 value) {
  set_has_from_id();
  from_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSendDelMsgToTargetRsp.from_id)
}

// optional bytes attach_data = 20;
inline bool IMSendDelMsgToTargetRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSendDelMsgToTargetRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSendDelMsgToTargetRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSendDelMsgToTargetRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSendDelMsgToTargetRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Buddy.IMSendDelMsgToTargetRsp.attach_data)
  return *attach_data_;
}
inline void IMSendDelMsgToTargetRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Buddy.IMSendDelMsgToTargetRsp.attach_data)
}
inline void IMSendDelMsgToTargetRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Buddy.IMSendDelMsgToTargetRsp.attach_data)
}
inline void IMSendDelMsgToTargetRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Buddy.IMSendDelMsgToTargetRsp.attach_data)
}
inline ::std::string* IMSendDelMsgToTargetRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Buddy.IMSendDelMsgToTargetRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMSendDelMsgToTargetRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSendDelMsgToTargetRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Buddy.IMSendDelMsgToTargetRsp.attach_data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Buddy
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
